---
title: "Take Home Exercise 3"
author: "Xu Haiyang"
date: "14 October, 2024" 
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

# **Prototyping Modules for Geospatial Analytics Shiny Application**

## **Overview**

Prototyping serves as a pivotal step in application development, bridging theoretical design with practical user interaction. A well-constructed prototype validates design decisions by providing a tangible platform to test user experience (UX) elements with stakeholders. This approach helps refine the application's UX before further resources are invested, enhancing both efficiency and effectiveness.

## **Prototyping for Shiny Application**

In the context of developing a **Shiny application** using **R**, prototyping plays a crucial role in defining technical requirements, testing functionality, and refining the user interface.

1.  **Evaluating R Packages**: The initial step in Shiny prototyping involves identifying and validating R packages from CRAN that support the app’s functionality. This ensures the application’s foundation is reliable and compatible with the required analyses and visualizations.

2.  **Testing R Code**: Prototyping also involves running and validating specific R code snippets to confirm they produce expected outputs. This testing process helps ensure a smooth experience for end-users by troubleshooting issues early.

3.  **Setting Parameters and Outputs**: Deciding on the parameters and outputs to expose in the application is a key step. These will guide user interaction and determine the dynamic nature of the app.

4.  **Designing the UI with Shiny Components**: The final prototyping phase involves selecting Shiny UI components that allow users to interact with the chosen parameters intuitively.

This structured approach facilitates a seamless transition from conceptual design to a fully functional application, prioritizing both technical robustness and user experience.

# **Understanding Basics of Shiny**

**Shiny** is an open-source R package designed to simplify the creation of interactive web applications without requiring knowledge of web design languages like HTML, CSS, or JavaScript.

### **Core Components of Shiny**

A Shiny application typically consists of an **`app.R`** file that includes two main sections:

1.  **User Interface (UI)** - Defines the front-end layout and elements that users interact with.

2.  **Server** - Contains the back-end logic, handling input-processing and output-rendering functions.

This modular structure keeps the UI and server functions distinct, ensuring a clean, organized codebase.

### **UI Layout in Shiny**

The Shiny UI includes components like:

1.  **Header Panel** (`headerPanel`): Displays the app’s title or brief descriptions.

2.  **Sidebar Panel** (`sidebarPanel`): A vertical panel for input controls, offering users a way to interact with the app.

3.  **Main Panel** (`mainPanel`): The primary area for output displays (e.g., maps, plots, tables).

### **Flexible Layout with FluidRow and Column**

Shiny employs a grid layout system through `fluidRow()` and `column()`, based on a 12-column structure, allowing flexible UI design. Each `fluidRow` can hold multiple `column` elements, enabling a variety of layouts by adjusting column widths.

### **Navbar Pages for Organized Layouts**

To structure complex applications, **`navbarPage()`** is available, enabling multiple sub-components within the app, each with distinct sidebar, tabset, or layout configurations.

### **User Inputs and Controls in Sidebar Panel**

Shiny provides various functions for defining user inputs, such as:

-   **`sliderInput()`**: Creates a slider for range-based input.

-   **`selectInput()`**: Generates a dropdown list.

-   **`textInput()`**: Adds a text box for user input.

-   **`numericInput()`**: Allows users to enter numeric values.

-   **`checkboxInput()` & `checkboxGroupInput()`**: Useful for binary or multiple-choice selections.

After configuring inputs, **`submitButton()`** compiles and sends inputs to the server, updating outputs accordingly.

### **Outputs in Main Panel**

Outputs are defined in the main panel with placeholders like:

-   **`textOutput()`**, **`tableOutput()`**, and **`plotOutput()`**.

-   Rendered on the UI via corresponding functions (`renderText`, `renderTable`, `renderPlot`), these components can be customized using `fluidRow()` and `column()`.

### **Organizing Outputs with Tabsets**

To segment content in the main panel, **`tabsetPanel()`** creates a series of tabs, helping organize multiple outputs within the application.

### **Server Component**

The server function processes inputs from the UI and defines outputs based on input values. It typically includes parameters for:

-   **Input**: Accesses user-specified UI inputs.

-   **Output**: Dictates output displays on the UI.

-   **Session** (optional): Manages session-specific settings.

The **UI and server interaction** is a two-way communication loop, where inputs from the UI are processed by the server, and the resulting outputs are displayed back on the UI.

# **Analysing R-Packages**

```{r}
pacman::p_load(spdep, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

This line uses `pacman::p_load` to load all necessary packages in one command, ensuring that all packages required for data manipulation, visualization, clustering, and spatial analysis are ready for use.

```{r}
vietnam_geo <- st_read(dsn = "data/geospatial/DiaphanTinh", layer = "Dia_phan_Tinh")
```

```{r}
write_rds(vietnam_geo, "data/rds/vietnam_geo.rds")
```

```{r}
glimpse(vietnam_geo)
```

```{r}
farms <- read_csv("data/aspatial/farms.csv") 
```

```{r}
summary(farms)
```

```{r}
enterprise <- read_csv("data/aspatial/enterprise.csv")
```

```{r}
farms <- farms %>%
  mutate(`Cities, provincies` = str_trim(`Cities, provincies`)) %>%
  filter(!`Cities, provincies` %in% c(
    "Red River Delta", "Northern midlands and mountain areas", 
    "Northern Central area and Central coastal area", "Central Highlands", 
    "South East", "Mekong River Delta"
  )) %>%
  mutate(`Cities, provincies` = case_when(
    `Cities, provincies` == "Ho Chi Minh city" ~ "TP. Ho Chi Minh",
    `Cities, provincies` == "Thai  Nguyen" ~ "Thai Nguyen",
    `Cities, provincies` == "Thua Thien-Hue" ~ "Thua Thien - Hue",
    `Cities, provincies` == "Quang  Nam" ~ "Quang Nam",
    `Cities, provincies` == "Quang  Ngai" ~ "Quang Ngai",
    `Cities, provincies` == "Khanh  Hoa" ~ "Khanh Hoa",
    `Cities, provincies` == "Ninh  Thuan" ~ "Ninh Thuan",
    `Cities, provincies` == "Binh  Duong" ~ "Binh Duong",
    `Cities, provincies` == "Kien  Giang" ~ "Kien Giang",
    TRUE ~ `Cities, provincies`
  )) %>%
  mutate(across(-`Cities, provincies`, ~str_replace_all(., "\\.\\.", "0"))) %>%
  mutate(across(-`Cities, provincies`, ~suppressWarnings(as.numeric(.))))

print(farms)
```

This segment cleans and standardizes province names in `farms`, trimming whitespace and correcting inconsistent naming conventions (e.g., replacing "Ho Chi Minh city" with "TP. Ho Chi Minh"). It also removes rows representing regions rather than specific provinces. Missing values, represented as `..`, are replaced with `0` to facilitate calculations, and remaining non-province columns are converted to numeric format to avoid errors in numeric operations.

```{r}
write_rds(farms, "data/rds/farms.rds")
```

```{r}
summary_stats <- farms %>%
  select(starts_with("2012"), starts_with("2013"), starts_with("2014"), starts_with("2015"),
         starts_with("2016"), starts_with("2017"), starts_with("2018"), starts_with("2019"),
         starts_with("2020"), starts_with("2021"), starts_with("2022"), starts_with("2023")) %>%
  summary()

print("Summary Statistics:")
print(summary_stats)
```

This code calculates and prints summary statistics for columns associated with the years 2012 through 2023. This gives a quick, aggregated view of each year’s data, providing insight into distributions and highlighting potential outliers or trends over time.

```{r}
farms <- farms %>%
  mutate(`2012 Cultivation PR` = `2012 Cultivation farm` / `2012 Total` * 1000,
         `2012 Livestock PR` = `2012 Livestock farm` / `2012 Total` * 1000,
         `2012 Fishing PR` = `2012 Fishing farm` / `2012 Total` * 1000,
         `2012 Others PR` = `2012 Others(*)` / `2012 Total` * 1000) %>%
  mutate(`2013 Cultivation PR` = `2013 Cultivation farm` / `2013 Total` * 1000,
         `2013 Livestock PR` = `2013 Livestock farm` / `2013 Total` * 1000,
         `2013 Fishing PR` = `2013 Fishing farm` / `2013 Total` * 1000,
         `2013 Others PR` = `2013 Others(*)` / `2013 Total` * 1000) %>%
  mutate(`2014 Cultivation PR` = `2014 Cultivation farm` / `2014 Total` * 1000,
         `2014 Livestock PR` = `2014 Livestock farm` / `2014 Total` * 1000,
         `2014 Fishing PR` = `2014 Fishing farm` / `2014 Total` * 1000,
         `2014 Others PR` = `2014 Others(*)` / `2014 Total` * 1000) %>%
  mutate(`2015 Cultivation PR` = `2015 Cultivation farm` / `2015 Total` * 1000,
         `2015 Livestock PR` = `2015 Livestock farm` / `2015 Total` * 1000,
         `2015 Fishing PR` = `2015 Fishing farm` / `2015 Total` * 1000,
         `2015 Others PR` = `2015 Others(*)` / `2015 Total` * 1000) %>%
  mutate(`2016 Cultivation PR` = `2016 Cultivation farm` / `2016 Total` * 1000,
         `2016 Livestock PR` = `2016 Livestock farm` / `2016 Total` * 1000,
         `2016 Fishing PR` = `2016 Fishing farm` / `2016 Total` * 1000,
         `2016 Others PR` = `2016 Others(*)` / `2016 Total` * 1000) %>%
  mutate(`2017 Cultivation PR` = `2017 Cultivation farm` / `2017 Total` * 1000,
         `2017 Livestock PR` = `2017 Livestock farm` / `2017 Total` * 1000,
         `2017 Fishing PR` = `2017 Fishing farm` / `2017 Total` * 1000,
         `2017 Others PR` = `2017 Others(*)` / `2017 Total` * 1000) %>%
  mutate(`2018 Cultivation PR` = `2018 Cultivation farm` / `2018 Total` * 1000,
         `2018 Livestock PR` = `2018 Livestock farm` / `2018 Total` * 1000,
         `2018 Fishing PR` = `2018 Fishing farm` / `2018 Total` * 1000,
         `2018 Others PR` = `2018 Others(*)` / `2018 Total` * 1000) %>%
  mutate(`2019 Cultivation PR` = `2019 Cultivation farm` / `2019 Total` * 1000,
         `2019 Livestock PR` = `2019 Livestock farm` / `2019 Total` * 1000,
         `2019 Fishing PR` = `2019 Fishing farm` / `2019 Total` * 1000,
         `2019 Others PR` = `2019 Others(*)` / `2019 Total` * 1000) %>%
  mutate(`2020 Cultivation PR` = `2020 Cultivation farm` / `2020 Total` * 1000,
         `2020 Livestock PR` = `2020 Livestock farm` / `2020 Total` * 1000,
         `2020 Fishing PR` = `2020 Fishing farm` / `2020 Total` * 1000,
         `2020 Others PR` = `2020 Others(*)` / `2020 Total` * 1000) %>%
  mutate(`2021 Cultivation PR` = `2021 Cultivation farm` / `2021 Total` * 1000,
         `2021 Livestock PR` = `2021 Livestock farm` / `2021 Total` * 1000,
         `2021 Fishing PR` = `2021 Fishing farm` / `2021 Total` * 1000,
         `2021 Others PR` = `2021 Others(*)` / `2021 Total` * 1000) %>%
  mutate(`2022 Cultivation PR` = `2022 Cultivation farm` / `2022 Total` * 1000,
         `2022 Livestock PR` = `2022 Livestock farm` / `2022 Total` * 1000,
         `2022 Fishing PR` = `2022 Fishing farm` / `2022 Total` * 1000,
         `2022 Others PR` = `2022 Others(*)` / `2022 Total` * 1000) %>%
  mutate(`2023 Cultivation PR` = `2023 Cultivation farm` / `2023 Total` * 1000,
         `2023 Livestock PR` = `2023 Livestock farm` / `2023 Total` * 1000,
         `2023 Fishing PR` = `2023 Fishing farm` / `2023 Total` * 1000,
         `2023 Others PR` = `2023 Others(*)` / `2023 Total` * 1000)
```

In this part, proportion ratios for various farm types (Cultivation, Livestock, Fishing, and Others) are calculated for each year, relative to the total farms. Scaling each type per 1,000 total farms allows us to compare regions with different total farm sizes on an equal footing, making it possible to see the proportionate focus of each province’s farming sector over time.

```{r}
enterprise <- enterprise %>%
  mutate(`Cities, provincies` = str_trim(`Cities, provincies`)) %>%
  filter(!`Cities, provincies` %in% c(
    "Red River Delta", "Northern midlands and mountain areas", 
    "Northern Central area and Central coastal area", "Central Highlands", 
    "South East", "Mekong River Delta"
  )) %>%
  mutate(`Cities, provincies` = case_when(
    `Cities, provincies` == "Ho Chi Minh city" ~ "TP. Ho Chi Minh",
    `Cities, provincies` == "Thai  Nguyen" ~ "Thai Nguyen",
    `Cities, provincies` == "Thua Thien-Hue" ~ "Thua Thien - Hue",
    `Cities, provincies` == "Quang  Nam" ~ "Quang Nam",
    `Cities, provincies` == "Quang  Ngai" ~ "Quang Ngai",
    `Cities, provincies` == "Khanh  Hoa" ~ "Khanh Hoa",
    `Cities, provincies` == "Ninh  Thuan" ~ "Ninh Thuan",
    `Cities, provincies` == "Binh  Duong" ~ "Binh Duong",
    `Cities, provincies` == "Kien  Giang" ~ "Kien Giang",
    TRUE ~ `Cities, provincies`
  )) %>%
  mutate(across(-`Cities, provincies`, ~str_replace_all(., "\\.\\.", "0"))) %>%
  mutate(across(-`Cities, provincies`, ~suppressWarnings(as.numeric(.))))

print(enterprise)
```

This segment cleans and standardizes province names in `enterprise`, trimming whitespace and correcting inconsistent naming conventions (e.g., replacing "Ho Chi Minh city" with "TP. Ho Chi Minh"). It also removes rows that represent regions rather than specific provinces, ensuring a focus on individual provincial data. Missing values, represented as "..", are replaced with 0 to enable smooth calculations, and all non-province columns are converted to numeric format to prevent errors in numeric operations.

```{r}
write_rds(enterprise, "data/rds/enterprise.rds")
```

## **Exploratory Data Analysis (EDA)**

When designing the Shiny UI, I plan to include the variable "type of farm," allowing users to explore the agricultural data across different years and farm types interactively.

```{r}
plots_list <- list()

for (year in 2012:2023) {
  p <- ggplot(farms, aes_string(x = paste0("`", year, " Cultivation farm`"))) +
    geom_histogram(fill = "skyblue", color = "black") +
    ggtitle(paste(year)) +
    theme_minimal()
  
  plots_list[[as.character(year)]] <- p
}

arranged_plot <- ggarrange(
  plots_list[["2012"]], plots_list[["2013"]], plots_list[["2014"]],
  plots_list[["2015"]], plots_list[["2016"]], plots_list[["2017"]],
  plots_list[["2018"]], plots_list[["2019"]], plots_list[["2020"]],
  plots_list[["2021"]], plots_list[["2022"]], plots_list[["2023"]],
  ncol = 4, nrow = 3
)

print(arranged_plot)
```

This code generates yearly histograms of "Cultivation farms" from 2012 to 2023, arranged in a grid layout. In the Shiny design, I will present these histograms, allowing users to explore the distribution of cultivation farms each year. Users will be able to select different years and compare the frequency distribution of cultivation farm counts over time.

```{r}
plots_list <- list()

for (year in 2016:2023) {
  p <- ggplot(enterprise, aes_string(x = paste0("`", year, "`"))) +
    geom_histogram(fill = "skyblue", color = "black") +
    ggtitle(paste(year)) +
    theme_minimal()
  
  plots_list[[as.character(year)]] <- p
}

arranged_plot <- ggarrange(
  plots_list[["2016"]], plots_list[["2017"]],
  plots_list[["2018"]], plots_list[["2019"]], plots_list[["2020"]],
  plots_list[["2021"]], plots_list[["2022"]], plots_list[["2023"]],
  ncol = 4, nrow = 2
)

final_plot <- annotate_figure(
  arranged_plot,
  top = text_grob("Number of Newly Established Enterprises (2016-2023)", 
                  face = "bold", size = 14)
)

print(final_plot)
```

This code generates histograms for each year from 2016 to 2023, showing the distribution of newly established enterprises. It first iterates through each year, creating a histogram with `ggplot` and saving it in `plots_list`. Each plot represents a single year’s distribution, with a consistent color scheme and minimalist styling.

This enterprise data is displayed alongside the farm histogram to allow comparison between farm and enterprise development over the years, suggesting other avenues of growth. In Shiny, I’ll add enterprise as a selection option, enabling users to toggle between enterprise and farm data and explore shifts in development focus across time. This approach helps users visually assess potential transitions from agriculture to enterprise-based growth in each province.

```{r}
farms %>%
  select(`2012 Cultivation farm`, `2013 Cultivation farm`, `2014 Cultivation farm`, 
         `2015 Cultivation farm`, `2016 Cultivation farm`, `2017 Cultivation farm`, 
         `2018 Cultivation farm`, `2019 Cultivation farm`, `2020 Cultivation farm`, 
         `2021 Cultivation farm`, `2022 Cultivation farm`, `2023 Cultivation farm`) %>%
  pivot_longer(cols = everything(), names_to = "Year", values_to = "Cultivation_Farms") %>%
  mutate(Year = gsub(" Cultivation farm", "", Year)) %>%  
  ggplot(aes(x = Year, y = Cultivation_Farms)) +
  geom_boxplot(fill = "orange") +
  ggtitle("Boxplot of Cultivation Farms (2012-2023)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  xlab("Year") + 
  ylab("Cultivation Farms") %>% 
  print()
```

I’ll display this boxplot on the Shiny UI, with the variable "Year" on the x-axis and "Cultivation Farms" on the y-axis. This visualization allows users to explore the distribution of cultivation farms over time, observing any changes in median values, variability, and outliers. Users can get insights into how cultivation has varied from year to year.

```{r}
enterprise %>%
  pivot_longer(cols = `2016`:`2023`, names_to = "Year", values_to = "Value") %>%
  ggplot(aes(x = Year, y = Value)) +
  geom_boxplot(fill = "orange") +
  ggtitle("Number of Newly Established Enterprises (2016-2023)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab("Year") +
  ylab("Number of Enterprises")
```

Positioning this enterprise boxplot alongside the farm boxplot in the Shiny app allows users to explore shifts in growth focus, comparing farm versus enterprise development over time. By including enterprise as a selectable option in the Shiny UI, users can toggle between the two datasets to observe and analyze trends, discovering insights into how regional development may be evolving from agriculture to business establishment in recent years.

```{r}
plots_list <- list()

for (year in 2012:2023) {
  p <- ggplot(farms, aes_string(x = paste0("`", year, " Cultivation PR`"))) +
    geom_histogram(fill = "skyblue", color = "black") +
    ggtitle(paste(year)) +
    theme_minimal()
  
  plots_list[[as.character(year)]] <- p
}

arranged_plot <- ggarrange(
  plots_list[["2012"]], plots_list[["2013"]], plots_list[["2014"]],
  plots_list[["2015"]], plots_list[["2016"]], plots_list[["2017"]],
  plots_list[["2018"]], plots_list[["2019"]], plots_list[["2020"]],
  plots_list[["2021"]], plots_list[["2022"]], plots_list[["2023"]],
  ncol = 4, nrow = 3
)

print(arranged_plot)
```

In Shiny, I’ll present these histograms of "Cultivation PR" (proportion per 1,000 farms) for each year from 2012 to 2023, enabling users to explore the cultivation farm proportion. By examining these histograms, users can see how the cultivation intensity varied year by year, which can highlight shifts in focus or growth in farming activity.

```{r}
sapply(farms %>% select(contains("Cultivation PR")), function(x) sum(is.na(x)))
```

This command checks for missing values in the "Cultivation PR" columns, ensuring data quality before display in Shiny.

```{r}
farms <- farms %>%
  mutate(across(where(is.numeric), ~replace_na(., 0)))
```

Here, I replace any remaining missing values with `0` to ensure complete and consistent data visualization within Shiny, preventing display issues with NA values.

```{r}
farms %>%
  select(`2012 Cultivation PR`, `2013 Cultivation PR`, `2014 Cultivation PR`, 
         `2015 Cultivation PR`, `2016 Cultivation PR`, `2017 Cultivation PR`, 
         `2018 Cultivation PR`, `2019 Cultivation PR`, `2020 Cultivation PR`, 
         `2021 Cultivation PR`, `2022 Cultivation PR`, `2023 Cultivation PR`) %>%
  pivot_longer(cols = everything(), names_to = "Year", values_to = "Cultivation_PR") %>%
  mutate(Year = gsub(" Cultivation PR", "", Year)) %>%
  ggplot(aes(x = Year, y = Cultivation_PR)) +
  geom_boxplot(fill = "orange") +
  ggtitle("Boxplot of Cultivation PR (2012-2023)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  xlab("Year") +  
  ylab("Cultivation PR (per 1000)") %>% 
  print()
```

This boxplot for "Cultivation PR" will also be displayed in the Shiny app, allowing users to explore how the proportion of cultivation farms has changed over the years. With variables "Year" and "Cultivation PR," users can observe fluctuations in farming intensity, identifying years with high or low cultivation proportions.

```{r}
vietnam_farm <- farms %>%
  left_join(vietnam_geo %>% select(-Code), by = c("Cities, provincies" = "Name"))

print(vietnam_farm)
```

By joining `farms` with `vietnam_geo` on matching province names, I create `vietnam_farm`, a comprehensive dataset combining both geographic and farm data. This joined dataset will be essential for displaying farm data across provinces on the Shiny map.

```{r}
write_rds(vietnam_farm, "data/rds/vietnam_farm.rds")
```

```{r}
vietnam_enterprise <- enterprise %>%
  left_join(vietnam_geo %>% select(-Code), by = c("Cities, provincies" = "Name"))

print(vietnam_enterprise)
```

```{r}
vietnam_farm <- st_as_sf(vietnam_farm)

qtm(vietnam_farm, "2012 Cultivation PR")
```

This code converts `vietnam_farm` into an `sf` spatial data frame and plots "2012 Cultivation PR" using `qtm`. In Shiny, this map will allow users to visually explore the cultivation farm proportion across different provinces, giving a clear geographic representation of farming intensity.

```{r}
tm_shape(vietnam_farm) +
  tm_polygons(c("2012 Total", "2012 Cultivation farm"),
              style = "jenks", 
              title = c("Total Farms in 2012", "Cultivation Farms in 2012")) +
  tm_facets(sync = TRUE, ncol = 2) +  
  tm_legend(legend.position = c("right", "bottom")) + 
  tm_layout(outer.margins = 0, asp = 0) 
```

This faceted map displays both "Total Farms" and "Cultivation Farms" for 2012, using `tm_facets` to create a synchronized side-by-side view. I’ll present these maps in Shiny to allow users to visually compare the distribution of total versus cultivation farms across provinces. This visualization, along with the option to explore variables by year, will provide a comprehensive geographic overview in the Shiny app.

```{r}
vietnam_enterprise <- st_as_sf(vietnam_enterprise)

tm_shape(vietnam_enterprise) +
  tm_polygons(c("2016", "2017"),
              style = "jenks", 
              title = c("New Enterprises (2016)", "New Enterprises (2017)")) +
  tm_facets(sync = TRUE, ncol = 2) +  
  tm_legend(legend.position = c("right", "bottom")) + 
  tm_layout(outer.margins = 0, asp = 0)
```

In Shiny, I’ll allow users to select different years to compare dynamically on a geographic map. Placed alongside farm distribution maps, these enterprise maps offer insights into potential regional shifts from agriculture to business growth. This setup lets users explore spatial differences year-to-year, revealing trends in economic development and regional focus over time.

```{r}
enterprise_long <- enterprise %>%
  pivot_longer(cols = `2016`:`2023`, names_to = "Year", values_to = "Enterprise_Count")

enterprise_long <- enterprise_long %>%
  mutate(Year = as.numeric(Year))

ggplot(data = enterprise_long, aes(x = Year, y = Enterprise_Count, color = `Cities, provincies`, group = `Cities, provincies`)) +
  geom_line() +
  geom_point() +
  ggtitle("Trend of Enterprises Over the Years (2016-2023)") +
  xlab("Year") +
  ylab("Enterprise Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

In the Shiny app, users will be able to select specific provinces to view enterprise trends over time, allowing them to focus on a particular province's growth trajectory. By enabling this selection, users can explore how enterprise development has varied among provinces, revealing insights into regional economic changes. This interactive feature will enhance user engagement and allow for targeted analysis of provincial trends.

## **Correlation Analysis**

When I design the Shiny UI, I will include the variable "year" to allow users to analyze and interact with correlation patterns over time.

```{r}
farm_2012_pr_data <- vietnam_farm %>%
  st_drop_geometry() %>%  
  select(`2012 Cultivation PR`, `2012 Livestock PR`, `2012 Fishing PR`, `2012 Others PR`) %>%
  mutate(across(everything(), as.numeric))  

colnames(farm_2012_pr_data) <- gsub("2012 ", "", colnames(farm_2012_pr_data))  

cluster_vars_cor_pr <- cor(farm_2012_pr_data, use = "complete.obs")

corrplot.mixed(cluster_vars_cor_pr,
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

This code calculates the correlation matrix for various farm types' proportions (Cultivation, Livestock, Fishing, Others) in 2012, removing geometry to focus on numeric data. Column names are cleaned to simplify variable names, and the `corrplot.mixed` function displays both numeric correlation values and ellipses, helping users easily interpret relationships between farm types. In Shiny, I’ll present this correlation plot to allow users to explore how different farming types relate to one another within a selected year.

![](images/clipboard-810687904.png)

### **Data Standardisation**

```{r}
vietnam_farm_ict <- vietnam_farm %>%
  st_drop_geometry() %>%  
  select_if(is.numeric)  
```

To prepare for standardization, this code removes geometry and retains only numeric data from `vietnam_farm`, creating `vietnam_farm_ict`. This selection forms the base data for applying both Min-Max and Z-score standardizations, which helps in visualizing different scaling methods and their impact on distribution.

### **Min-Max standardisation**

```{r}
vietnam_farm.std <- normalize(vietnam_farm_ict)

summary(vietnam_farm.std)
```

Applying Min-Max standardization scales the data to a range of 0 to 1, making it easier to compare variables with different units or ranges. The summary provides insights into how variables are rescaled. In Shiny, this standardization option will allow users to toggle between raw and normalized data views to understand how scaling affects the data distribution.

### **Z-score standardisation**

```{r}
vietnam_farm.z <- scale(vietnam_farm_ict)
describe(vietnam_farm.z)
```

Z-score standardization adjusts each variable to have a mean of 0 and a standard deviation of 1. This method is useful for comparing variables on a common scale without the influence of original units. In Shiny, users will be able to view data using this standardization method, making it easier to detect outliers or extreme values across farm types.

### **Visualising the standardised clustering variables**

To provide users with a complete understanding of the raw and standardized values, I plan to incorporate the options "type of farm," "year," and "selection" (histogram or density) into the Shiny UI.

```{r}
r <- ggplot(data = vietnam_farm_ict, 
            aes(x = `2012 Cultivation PR`)) +
  geom_histogram(bins = 20, 
                 color = "black", 
                 fill = "light blue") +
  ggtitle("Raw Values (without Standardization)")

vietnam_farm_std_df <- as.data.frame(vietnam_farm.std)

s <- ggplot(data = vietnam_farm_std_df, 
            aes(x = `2012 Cultivation PR`)) +
  geom_histogram(bins = 20, 
                 color = "black", 
                 fill = "light blue") +
  ggtitle("Min-Max Standardization")

vietnam_farm_z_df <- as.data.frame(vietnam_farm.z)

z <- ggplot(data = vietnam_farm_z_df, 
            aes(x = `2012 Cultivation PR`)) +
  geom_histogram(bins = 20, 
                 color = "black", 
                 fill = "light blue") +
  ggtitle("Z-score Standardization")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

Here, histograms compare the distribution of "Cultivation PR" for 2012 under three conditions: raw values, Min-Max standardized, and Z-score standardized. In the Shiny UI, I’ll present these options to allow users to view the impact of different standardization methods on the data. This visualization will help users understand how scaling changes the data’s spread and enables them to select the most informative view for their analysis.

```{r}
r <- ggplot(data = vietnam_farm_ict, 
            aes(x = `2012 Cultivation PR`)) +
  geom_density(color = "black", 
               fill = "light blue") +
  ggtitle("Raw Values (without Standardization)")

vietnam_farm_std_df <- as.data.frame(vietnam_farm.std)

s <- ggplot(data = vietnam_farm_std_df, 
            aes(x = `2012 Cultivation PR`)) +
  geom_density(color = "black", 
               fill = "light blue") +
  ggtitle("Min-Max Standardization")

vietnam_farm_z_df <- as.data.frame(vietnam_farm.z)

z <- ggplot(data = vietnam_farm_z_df, 
            aes(x = `2012 Cultivation PR`)) +
  geom_density(color = "black", 
               fill = "light blue") +
  ggtitle("Z-score Standardization")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

Similar to the histograms, these density plots display the distribution of "Cultivation PR" for 2012 under raw, Min-Max, and Z-score standardizations. In Shiny, I’ll offer a choice between histogram and density plot types so users can explore the data distribution in the format that best suits their analysis. These density plots provide a smoother view of data spread, aiding users in understanding variability and data concentration more intuitively.

![](images/clipboard-810687904.png)

### **Computing proximity matrix**

When designing the Shiny UI, I’ll include the variable "year," allowing users to explore data clustering for different years.

```{r}
vietnam_farm_ict_2012 <- vietnam_farm %>%
  st_drop_geometry() %>%
  select(matches("^2012.*(PR|farm|Others\\(\\*\\))"))
```

This code creates a subset of `vietnam_farm` containing only 2012 data for variables related to farm counts and proportions. Removing geometry with `st_drop_geometry()` makes it easier to compute distances for numeric data only.

```{r}
proxmat <- dist(vietnam_farm_ict_2012, method = 'euclidean')
```

Here, I calculate a proximity matrix using Euclidean distance, which measures similarity across provinces based on their farm metrics. This proximity matrix is foundational for clustering analysis in Shiny, helping users see how similar or different provinces are from each other based on the chosen year.

### **Computing hierarchical clustering**

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

Using the `ward.D` method, this line creates a hierarchical clustering model based on the computed proximity matrix. The Ward method minimizes variance within clusters, making it ideal for grouping provinces with similar farm characteristics.

### **Selecting the optimal clustering algorithm**

```{r}
m <- c("average", "single", "complete", "ward")
names(m) <- c("average", "single", "complete", "ward")

ac <- function(x) {
  agnes(vietnam_farm_ict_2012, method = x)$ac 
}

ac_values <- map_dbl(m, ac)

print(ac_values)
```

To identify the best clustering method, I calculate the agglomerative coefficient (`ac`) for multiple algorithms (average, single, complete, and ward). Higher `ac` values indicate more compact clusters. In Shiny, users will be able to choose their preferred clustering method based on these coefficients, helping them explore the segmentation of provinces under different methods.

### **Determining Optimal Clusters**

```{r}
set.seed(12345)

gap_stat <- clusGap(vietnam_farm_ict_2012, 
                    FUN = hcut,      
                    nstart = 25,     
                    K.max = 10, 
                    B = 50)          

print(gap_stat, method = "firstmax")
```

```{r}
fviz_gap_stat(gap_stat)
```

The `clusGap` function uses gap statistics to determine the optimal number of clusters (K) by comparing clustering quality across different K values. In Shiny, I’ll include the option to adjust K values, allowing users to view how segmentation quality changes and helping them select an ideal number of clusters based on the gap statistic plot.

![](images/clipboard-42895384.png)

### **Interpreting the dendrograms**

When designing the Shiny UI, I will include the variable: k value and variable: year to enable users to explore clustering results in detail.

```{r}
plot(hclust_ward, labels = vietnam_farm$`Cities, provincies`, cex = 0.7)
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:5)
```

The dendrogram plot visualizes hierarchical clustering, with rectangles drawn around six clusters to show grouping. In Shiny, I’ll include adjustable K values, allowing users to choose the number of clusters (K) interactively and visualize how provinces group under different K values.

```{r}
vietnam_farm_ict_mat <- data.matrix(vietnam_farm_ict_2012)
```

This line converts the `vietnam_farm_ict_2012` data frame into a matrix format for use in clustering and heatmap visualization.

#### Plotting interactive cluster heatmap using *heatmaply()*

When designing the Shiny UI, I will include variable: k value and variable: year to allow users to customize the heatmap view.

```{r}
vietnam_farm_ict_pr_2012 <- vietnam_farm %>%
  st_drop_geometry() %>%
  select(matches("^2012.*PR$")) %>%
  mutate(across(everything(), ~replace_na(as.numeric(.), 0)))

rownames(vietnam_farm_ict_pr_2012) <- vietnam_farm$`Cities, provincies`

vietnam_farm_ict_pr_2012_std <- normalize(vietnam_farm_ict_pr_2012)

heatmaply(
  vietnam_farm_ict_pr_2012_std,
  Colv = NA,
  dist_method = "euclidean",
  hclust_method = "ward.D",
  seriate = "OLO",
  colors = Blues,
  k_row = 6,
  margins = c(NA, 200, 60, NA),
  fontsize_row = 4,
  fontsize_col = 5,
  main = "Geographic Segmentation of Vietnam Farms by ICT Indicators (2012)",
  xlab = "ICT Indicators",
  ylab = "Provinces of Vietnam"
)
```

In this heatmap, the selected farm proportions are normalized for 2012, and a Ward hierarchical clustering model is applied. The heatmap groups similar provinces based on ICT indicators and displays the intensity of each metric by color. Within the Shiny UI, I’ll allow users to adjust K values and explore clustering structures interactively, making it easy to identify similar clusters among provinces visually.

![](images/clipboard-2260834031.png)

### **Mapping the clusters formed**

When designing the Shiny UI, I will include options for variable: k value and variable: year, allowing users to dynamically adjust the number of clusters and explore clusters across different years.

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

This line creates a grouping variable (`groups`) by cutting the hierarchical clustering dendrogram at K=6 clusters, assigning each province to one of the clusters.

```{r}
vietnam_farm_cluster <- cbind(vietnam_farm, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

Next, I add the `groups` variable to `vietnam_farm`, renaming it as `CLUSTER`. This combined data frame (`vietnam_farm_cluster`) now includes cluster assignments, making it ready for spatial visualization.

```{r}
qtm(vietnam_farm_cluster, "CLUSTER")
```

Using `qtm`, I map the clusters for visualization. In Shiny, this map will allow users to view how provinces are grouped based on farm characteristics for a selected year, with an adjustable K value so users can see how different cluster numbers impact segmentation.

## **Spatially Constrained Clustering: SKATER approach**

The SKATER approach adds spatial constraints to clustering, ensuring clusters are contiguous geographically, which is useful in spatial analysis.

```{r}
vietnam_farm_sp <- as_Spatial(vietnam_farm)
```

To work with SKATER, the `vietnam_farm` dataset is converted into a spatial format (`vietnam_farm_sp`), making it compatible with functions that require spatial data structure.

### **Computing Neighbour List**

```{r}
vietnam_farm.nb <- poly2nb(vietnam_farm_sp)
summary(vietnam_farm.nb)
```

This computes the neighborhood list for each province using adjacency, helping to establish spatial relationships necessary for the SKATER algorithm. In Shiny, this process allows for geographically informed clustering based on the provinces’ proximity to each other.

```{r}
coords <- st_coordinates(
  st_centroid(st_geometry(vietnam_farm)))
```

This code calculates the centroid coordinates of each province, used to assess spatial relationships and visualize each cluster’s spatial configuration accurately.

### **Computing minimum spanning tree**

```{r}
lcosts <- nbcosts(vietnam_farm.nb, vietnam_farm_ict_2012)
```

The `nbcosts` function calculates edge costs based on Euclidean distances, indicating the cost of connecting each province to its neighbors. This will help in creating a minimum spanning tree for clustering.

```{r}
vietnam_farm.w <- nb2listw(vietnam_farm.nb, 
                   lcosts, 
                   style="B")
summary(vietnam_farm.w)
```

Using the neighborhood list and calculated costs, I create a spatial weights list (`vietnam_farm.w`). The weights define connectivity and are crucial for forming the minimum spanning tree in the SKATER method.

```{r}
vietnam_farm.mst <- mstree(vietnam_farm.w)
```

The minimum spanning tree (`vietnam_farm.mst`) is created, providing the basis for spatially constrained clusters by ensuring that clusters are spatially connected.

### **Computing spatially constrained clusters using SKATER method**

When designing the Shiny UI, I will include variable: year and selection of `ncuts` to allow users to interactively select both the year and the number of clusters they wish to analyze.

```{r}
clust <- spdep::skater(edges = vietnam_farm.mst[,1:2], 
                 data = vietnam_farm_ict_2012, 
                 method = "euclidean", 
                 ncuts = 5)
```

Using the SKATER method, spatially constrained clusters are created based on the minimum spanning tree, using Euclidean distance to determine the cost of connecting provinces. By including `ncuts` as a selectable parameter in Shiny, users can explore how changing the number of clusters impacts spatial segmentation. This flexibility allows them to see various cluster configurations and observe how spatial constraints shape cluster formation across different parameter choices.

### **Visualising the clusters in choropleth map**

When designing the Shiny UI, I will include variable: year so users can interactively select the year for analysis and variable: K value to adjust the number of clusters.

```{r}
groups_mat <- as.matrix(clust$groups)
vietnam_farm_spatialcluster <- cbind(vietnam_farm_cluster, as.factor(groups_mat)) %>%
  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)
qtm(vietnam_farm_spatialcluster, "SP_CLUSTER")
```

This code binds the spatially constrained cluster groups to the data and renames the cluster column as `SP_CLUSTER`. The `qtm` function then visualizes these clusters, allowing users to see spatial cluster distributions directly on the map.

```{r}
hclust.map <- qtm(vietnam_farm_cluster,
                  "CLUSTER") + 
  tm_borders(alpha = 0.5) 

shclust.map <- qtm(vietnam_farm_spatialcluster,
                   "SP_CLUSTER") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(hclust.map, shclust.map,
             asp=NA, ncol=2)
```

Using `tmap_arrange`, I display both the regular and spatially constrained clusters side-by-side, providing users with a comparative view of the cluster types for a given year. The Shiny app will feature year and K value selectors to let users see how clusters vary by different configurations.

![](images/clipboard-907982601.png)

## **Spatially Constrained Clustering: ClustGeo Method**

### **Ward-like hierarchical clustering: ClustGeo**

In the Shiny UI, I will include **variable: year** and **variable: K value** so users can explore different years and adjust the number of clusters.

```{r}
nongeo_cluster <- hclustgeo(proxmat)
plot(nongeo_cluster, cex = 0.5)
rect.hclust(nongeo_cluster, 
            k = 6, 
            border = 2:5)
```

The `hclustgeo` function performs hierarchical clustering based on the proximity matrix, producing a dendrogram. Users can select **K values** in Shiny to visualize different clustering arrangements on the dendrogram, adjusting to see various levels of grouping across the chosen year.

![](images/clipboard-1682337348.png)

#### Mapping the clusters formed

```{r}
groups <- as.factor(cutree(nongeo_cluster, k=6))
```

```{r}
vietnam_farm_ngeo_cluster <- cbind(vietnam_farm, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

This code assigns each province to a cluster (based on `K=6`) and renames the column `CLUSTER`, allowing us to map and display the clusters in Shiny with an adjustable **K value** and **year** for user-driven exploration.

```{r}
qtm(vietnam_farm_ngeo_cluster, "CLUSTER")
```

The `qtm` function visualizes these ClustGeo-based clusters, showing spatially relevant groupings across provinces.

### **Spatially Constrained Hierarchical Clustering**

```{r}
dist <- st_distance(vietnam_farm, vietnam_farm)
distmat <- as.dist(dist)
```

This line calculates spatial distances between provinces, forming a distance matrix essential for combining spatial constraints with ClustGeo clustering.

```{r}
cr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)
```

Using `choicealpha`, I generate a plot that helps select the optimal balance (`alpha`) between geographic distance and attribute-based clustering, aiding in refining clusters by integrating spatial proximity.

```{r}
clustG <- hclustgeo(proxmat, distmat, alpha = 0.2)
```

This command performs spatially constrained clustering with a specific `alpha` value (0.2), balancing geographic and attribute-based clustering. In Shiny, users will select **K value** and **year** for visualizing clusters under different constraints.

![](images/clipboard-3960457669.png)

```{r}
groups <- as.factor(cutree(clustG, k=6))
```

```{r}
vietnam_farm_Gcluster <- cbind(vietnam_farm, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

After assigning clusters based on `K=6`, this code binds cluster groupings to the data, allowing each province to be categorized by its cluster number.

```{r}
qtm(vietnam_farm_Gcluster, "CLUSTER")
```

The `qtm` map of `CLUSTER` displays the spatially constrained hierarchical clustering for each province, allowing users to examine cluster distributions in Shiny with selectable year and cluster parameters.

## **Visual Interpretation of Clusters**

When designing the Shiny UI, I will include **variable: year** and **variable: K value** to give users flexibility in examining clustering results across years and different cluster groupings.

```{r}
ggplot(data = vietnam_farm_ngeo_cluster, aes(x = CLUSTER, y = `X2012.Cultivation.PR`)) + geom_boxplot()
```

This boxplot shows the distribution of `Cultivation PR` within each cluster for the year 2012, providing insights into how similar or varied the clusters are in terms of cultivation proportions. In Shiny, users can adjust **K values** and **years** to explore how clusters relate to different farm indicators.

![](images/clipboard-1921262520.png)

### **Multivariate Visualisation**

In the Shiny UI, I will include **variable: year**, **K value**, and the option to explore farm indicators across clusters for multivariate analysis.

```{r}
ggparcoord(data = vietnam_farm_ngeo_cluster, 
           columns = c(62:65), 
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of ICT Variables by Cluster (2012)") +
  facet_grid(~ CLUSTER) + 
  theme(axis.text.x = element_text(angle = 30)) +
  scale_x_discrete(labels = c(
    "X2012.Cultivation.PR" = "Cultivation PR",
    "X2012.Livestock.PR" = "Livestock PR",
    "X2012.Fishing.PR" = "Fishing PR",
    "X2012.Others.PR" = "Others PR"
  ))
```

Using parallel coordinate plots, this visualization allows users to view multiple farm indicators across clusters, with variables standardized on a global min-max scale. In Shiny, users can interactively explore these multivariate relationships by adjusting **year** and **K values**, gaining insights into how different farm types are distributed across clusters.
