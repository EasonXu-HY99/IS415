---
title: "Hands on Exercise 8"
author: "Xu Haiyang"
date: "14 October, 2024" 
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

# **Overview Explanation**

In this hands-on exercise, I gained practical experience in delineating homogeneous regions using geographically referenced multivariate data. The analysis consists of two main techniques: hierarchical cluster analysis and spatially constrained cluster analysis.

### **Learning Outcome Explanation**

By completing this exercise, I learned how to:

-   Convert GIS polygon data into an R simple feature `data.frame` using appropriate functions from the `sf` package.

-   Transform the simple feature `data.frame` into an R `SpatialPolygonDataFrame` object using relevant functions from the `sf` package.

-   Perform cluster analysis using `hclust()` from Base R.

-   Execute spatially constrained cluster analysis with `skater()` from Base R.

-   Visualize the analysis output through the `ggplot2` and `tmap` packages.

### **Getting Started Explanation**

#### **Analytical Question**

In spatial policy and geobusiness, it is common to divide markets or planning areas into homogeneous regions using multivariate data. In this exercise, I focused on dividing Shan State in Myanmar into homogeneous regions using several Information and Communication Technology (ICT) indicators, including Radio, Television, Landline Phone, Mobile Phone, Computer, and Internet at home.

### **Installing and Loading R Packages Explanation**

In the code provided, I installed and loaded several R packages using `pacman::p_load()`, which efficiently manages package installation and loading:

```{r}
pacman::p_load(spdep, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

## **Data Import and Preparation Explanation**

#### **Importing Geospatial Data into R Environment**

I used the `st_read()` function from the `sf` package to read geospatial data for Myanmar township boundaries. I filtered the data to only include three regions of Shan State (East, North, and South) and selected columns 2 to 7. The resultant geospatial data was stored in `shan_sf`:

```{r}
shan_sf <- st_read(dsn = "data/geospatial", 
                   layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```

The dataset is then displayed using the following functions:

```{r}
shan_sf
```

```{r}
glimpse(shan_sf)
```

#### **Importing Aspatial Data into R Environment**

The aspatial dataset, which contains ICT-related data for Shan State, is imported using `read_csv()`:

```{r}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")
```

```{r}
summary(ict)
```

## **Spatially Constrained Clustering: SKATER approach**

```{r}
shan_sp <- as_Spatial(shan_sf)
```

### **Computing Neighbour List**

```{r}
shan.nb <- poly2nb(shan_sp)
summary(shan.nb)
```

```{r}
coords <- st_coordinates(
  st_centroid(st_geometry(shan_sf)))
```

```{r}
plot(st_geometry(shan_sf), 
     border=grey(.5))
plot(shan.nb,
     coords, 
     col="blue", 
     add=TRUE)
```

### **Computing minimum spanning tree**

#### Calculating edge costs

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

```{r}
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
  
write_rds(shan_sf, "data/rds/shan_sf.rds")
```

```{r}
shan_sf <- read_rds("data/rds/shan_sf.rds")
```

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)

write_rds(shan_ict, "data/rds/shan_ict.rds")
```

```{r}
shan_ict <- read_rds("data/rds/shan_ict.rds")
```

```{r}
lcosts <- nbcosts(shan.nb, shan_ict)
```

```{r}
shan.w <- nb2listw(shan.nb, 
                   lcosts, 
                   style="B")
summary(shan.w)
```

### **Computing minimum spanning tree**

```{r}
shan.mst <- mstree(shan.w)
```

```{r}
class(shan.mst)
```

```{r}
dim(shan.mst)
```

```{r}
head(shan.mst)
```

```{r}
plot(st_geometry(shan_sf), 
                 border=gray(.5))
plot.mst(shan.mst, 
         coords, 
         col="blue", 
         cex.lab=0.7, 
         cex.circles=0.005, 
         add=TRUE)
```

### **Computing spatially constrained clusters using SKATER method**

```{r}
clust6 <- spdep::skater(edges = shan.mst[,1:2], 
                 data = shan_ict, 
                 method = "euclidean", 
                 ncuts = 5)
```

```{r}
str(clust6)
```

```{r}
ccs6 <- clust6$groups
ccs6
```

```{r}
table(ccs6)
```

```{r}
plot(st_geometry(shan_sf), 
     border=gray(.5))
plot(clust6, 
     coords, 
     cex.lab=.7,
     groups.colors=c("red","green","blue", "brown", "pink"),
     cex.circles=0.005, 
     add=TRUE)
```

### **Visualising the clusters in choropleth map**

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

```{r}
groups_mat <- as.matrix(clust6$groups)
shan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%
  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)
qtm(shan_sf_spatialcluster, "SP_CLUSTER")
```

```{r}
hclust.map <- qtm(shan_sf_cluster,
                  "CLUSTER") + 
  tm_borders(alpha = 0.5) 

shclust.map <- qtm(shan_sf_spatialcluster,
                   "SP_CLUSTER") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(hclust.map, shclust.map,
             asp=NA, ncol=2)
```

## **Spatially Constrained Clustering: ClustGeo Method**

### **A short note about ClustGeo package**

[**ClustGeo**](https://cran.r-project.org/web/packages/ClustGeo/) package is an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints.

In the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \[0, 1\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.

The idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.

### **Ward-like hierarchical clustering: ClustGeo**

```{r}
nongeo_cluster <- hclustgeo(proxmat)
plot(nongeo_cluster, cex = 0.5)
rect.hclust(nongeo_cluster, 
            k = 6, 
            border = 2:5)
```

#### Mapping the clusters formed

```{r}
groups <- as.factor(cutree(nongeo_cluster, k=6))
```

```{r}
shan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

```{r}
qtm(shan_sf_ngeo_cluster, "CLUSTER")
```

### **Spatially Constrained Hierarchical Clustering**

```{r}
dist <- st_distance(shan_sf, shan_sf)
distmat <- as.dist(dist)
```

```{r}
cr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)
```

```{r}
clustG <- hclustgeo(proxmat, distmat, alpha = 0.2)
```

```{r}
groups <- as.factor(cutree(clustG, k=6))
```

```{r}
shan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

```{r}
shan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

```{r}
qtm(shan_sf_Gcluster, "CLUSTER")
```
