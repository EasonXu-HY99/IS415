{
  "hash": "30b74413295b9b905292f30cc210add6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 3\"\nauthor: \"Xu Haiyang\"\ndate: \"2 September, 2024\" \ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\nIn R, `set.seed()` is a function used to set the seed of the random number generator. This is important when you want to ensure reproducibility in your code, especially when you're working with functions that involve random number generation, such as simulations, sampling, or generating random numbers. (from ChatGPT)\n\nWhen you use `set.seed()` with a specific integer value, it initializes the random number generator to a specific state. This means that every time you run the same code with the same seed, you will get the same sequence of random numbers. This is particularly useful when you want to share your code with others or when you want to debug your code, as it ensures that your results are consistent and reproducible. (from ChatGPT)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Set the seed to 123\nsample(1:10, 5)# Output: 3 9 4 7 6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3 10  2  8  6\n```\n\n\n:::\n:::\n\n\nIf you run the same code again with `set.seed(123)`, you will get the same output every time. (from ChatGPT)\n\n====================================================================\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maptools\", repos = \"https://packagemanager.posit.co/cran/2023-10-13\")\n```\n:::\n\n\n-   `st_combine()` returns a single, combined geometry, with no resolved boundaries; returned geometries may well be invalid. It simply groups geometries together without performing any topological operations or considering the relationships between the geometries.\n\n    On the other hand, `st_union()`:\n\n-   `st_union()` returns a single geometry that represents the union of all geometries. Unlike `st_combine()`, `st_union()` performs topological operations to resolve boundaries and overlaps between geometries. It merges overlapping or touching geometries into one cohesive shape, ensuring that the returned geometry is valid. This function is often used when you need a true geometric union where boundaries are properly accounted for and combined.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, raster, spatstat, tmap, tidyverse)\nmpsz_sf <- st_read(dsn = \"data\", layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\EasonXu-HY99\\IS415\\In-class_Ex\\In-class_Ex03\\data' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nsg_sf <- mpsz_sf %>%\n  st_union()\n```\n:::\n\n\n`st_union()` is used to derive the coatal outline sf tibble data.frme\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf <- readr::read_csv(\"data/ACLED_Myanmar.csv\") %>%\n  st_as_sf(coords = c( \"longitude\",\"latitude\"), crs = 4326) %>%\n  st_transform(crs = 32647) %>%\n    mutate(event_date = dmy(event_date))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 55574 Columns: 31\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (20): event_id_cnty, event_date, disorder_type, event_type, sub_event_ty...\ndbl (11): year, time_precision, inter1, inter2, interaction, iso, latitude, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}