{
  "hash": "bd885060e4288c6d4e9e79e52cf363f2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 3\"\nauthor: \"Xu Haiyang\"\ndate: \"2 September, 2024\" \ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\nIn R, `set.seed()` is a function used to set the seed of the random number generator. This is important when you want to ensure reproducibility in your code, especially when you're working with functions that involve random number generation, such as simulations, sampling, or generating random numbers. (from ChatGPT)\n\nWhen you use `set.seed()` with a specific integer value, it initializes the random number generator to a specific state. This means that every time you run the same code with the same seed, you will get the same sequence of random numbers. This is particularly useful when you want to share your code with others or when you want to debug your code, as it ensures that your results are consistent and reproducible. (from ChatGPT)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Set the seed to 123\nsample(1:10, 5)# Output: 3 9 4 7 6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3 10  2  8  6\n```\n\n\n:::\n:::\n\n\nIf you run the same code again with `set.seed(123)`, you will get the same output every time. (from ChatGPT)\n\n====================================================================\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maptools\", repos = \"https://packagemanager.posit.co/cran/2023-10-13\")\n```\n:::\n\n\n-   `st_combine()` returns a singe. combined geometry, with no resolved boundaries; returned geometries may well be invalid.\n-   `st_union()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, raster, spatstat, tmap, tidyverse)\nmpsz_sf <- st_read(dsn = \"data\", layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\EasonXu-HY99\\IS415\\In-class_Ex\\In-class_Ex03\\data' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nsg_sf <- mpsz_sf %>%\n  st_union()\n```\n:::\n\n\n`st_union()` is used to derive the coatal outline sf tibble data.frme\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf <- readr::read_csv(\"data/ACLED_Myanmar.csv\") %>%\n  st_as_sf(coords = c( \"longitude\",\"latitude\"), crs = 4326) %>%\n  st_transform(crs = 32647) %>%\n    mutate(event_date = dmy(event_date))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 55574 Columns: 31\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (20): event_id_cnty, event_date, disorder_type, event_type, sub_event_ty...\ndbl (11): year, time_precision, inter1, inter2, interaction, iso, latitude, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}