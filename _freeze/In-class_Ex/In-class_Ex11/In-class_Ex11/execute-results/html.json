{
  "hash": "6ca013b00767c6c124bc05acc6257f20",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In Class Exercise 11\"\nauthor: \"Xu Haiyang\"\ndate: \"4 November, 2024\" \ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n\n\n\n### Loading Required Libraries\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, sf, tmap, httr, performance)\n```\n:::\n\n\n\n\n\nThis line loads essential packages for data wrangling, geospatial analysis, mapping, HTTP requests, and model performance checks.\n\n### **Reading and Merging CSV Files**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfolder_path <- \"data/aspatial\"\nfile_list <- list.files(path = folder_path, \n                        pattern = \"^realis.*\\\\.csv$\", \n                        full.names = TRUE)\n\nrealis_data <- file_list %>%\n  map_dfr(read_csv)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 10000 Columns: 21\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (15): Project Name, Sale Date, Address, Type of Sale, Type of Area, Nett...\ndbl  (2): Area (SQM), Number of Units\nnum  (4): Transacted Price ($), Area (SQFT), Unit Price ($ PSF), Unit Price ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nRows: 6643 Columns: 21\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (15): Project Name, Sale Date, Address, Type of Sale, Type of Area, Nett...\ndbl  (1): Number of Units\nnum  (5): Transacted Price ($), Area (SQFT), Unit Price ($ PSF), Area (SQM),...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n\n\nThis block identifies all files in the specified folder that start with \"realis\" and end with \".csv\". It reads and combines them into a single data frame (`realis_data`) using `map_dfr()`, which applies `read_csv()` to each file.\n\n### **Filtering for Condo Resale Transactions**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncondo_resale <- realis_data %>%\n  mutate(`Sale Date` = dmy(`Sale Date`)) %>%\n  filter(`Type of Sale` == \"Resale\" &\n           `Property Type` == \"Condominium\")\n```\n:::\n\n\n\n\n\nThis code block:\n\n1.  Converts the `Sale Date` column to a date format.\n\n2.  Filters the dataset to include only records where the sale type is \"Resale\" and the property type is \"Condominium.\"\n\n### **Extracting Unique Postcodes**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npostcode <- unique(condo_resale$`Postal Code`)\n```\n:::\n\n\n\n\n\nThis line creates a unique list of postal codes from the filtered condo resale data for geocoding.\n\n### **Geocoding Using OneMap API**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl <- \"https://onemap.gov.sg/api/common/elastic/search\"\nfound <- data.frame()\nnot_found <- data.frame()\n\nfor (postcode in postcode){\n  query <- list('searchVal'=postcode, 'returnGeom'='Y', \n                'getAddrDetails'='Y', 'pageNum'='1')\n  res <- GET(url, query=query)\n  if ((content(res)$found)!=0){\n    found <- rbind(found, data.frame(content(res))[4:13])\n  } else {not_found = data.frame(postcode)\n  }\n}\n```\n:::\n\n\n\n\n\nThis loop sends a request for each unique postal code to the OneMap API to obtain coordinates. It checks if a result was found:\n\n-   If found, relevant data (columns 4 to 13) is added to the `found` data frame.\n\n-   If not found, the postal code is added to the `not_found` data frame.\n\n### **Selecting and Renaming Geocoded Data Columns**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfound <- found %>%\n  select(c(6:8)) %>%\n  rename(POSTAL = `results.POSTAL`,\n         XCOORD = `results.X`,\n         YCOORD = `results.Y`)\n```\n:::\n\n\n\n\n\nThis code keeps only the essential columns (`POSTAL`, `XCOORD`, and `YCOORD`) from the geocoded data and renames them for clarity.\n\n### **Joining Geocoded Coordinates with Condo Resale Data**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncondo_resale_geocoded = left_join(\n  condo_resale, found, \n  by = c('Postal Code' = 'POSTAL'))\n```\n:::\n\n\n\n\n\nUsing a left join, this merges the geocoded coordinates with the condo resale data based on the postal code.\n\n### **Converting Data Frame to Spatial Object**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncondo_resale_sf <- st_as_sf(condo_resale_geocoded, \n                            coords = c(\"XCOORD\",\n                                       \"YCOORD\"),\n                            crs=3414)\n```\n:::\n\n\n\n\n\nThis line converts the merged data frame into an `sf` object with the specified coordinate reference system (CRS: EPSG 3414, SVY21).\n\n### **Identifying Overlapping Points**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noverlapping_points <- condo_resale_sf %>%\n  mutate(overlap = lengths(st_equals(., .)) > 1)\n```\n:::\n\n\n\n\n\nThis code identifies points that overlap with others by checking for geometrically identical points (using `st_equals`). It adds an `overlap` column that marks overlapping points as `TRUE`.\n\n### **Applying Jitter to Overlapping Points**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncondo_resale_sf <- condo_resale_sf %>%\n  st_jitter(amount = 2)\n```\n:::\n\n\n\n\n\nTo visually separate overlapping points on a map, a small random offset (jitter) is applied to each point’s coordinates by 2 meters. This improves spatial visualization by preventing points from stacking directly on top of each other.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}