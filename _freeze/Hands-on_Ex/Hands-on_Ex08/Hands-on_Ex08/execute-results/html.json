{
  "hash": "00e5e0211df43a7273ba22b386cb5723",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands on Exercise 8\"\nauthor: \"Xu Haiyang\"\ndate: \"14 October, 2024\" \ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n\n# **Overview Explanation**\n\nIn this hands-on exercise, I gained practical experience in delineating homogeneous regions using geographically referenced multivariate data. The analysis consists of two main techniques: hierarchical cluster analysis and spatially constrained cluster analysis.\n\n### **Learning Outcome Explanation**\n\nBy completing this exercise, I learned how to:\n\n-   Convert GIS polygon data into an R simple feature `data.frame` using appropriate functions from the `sf` package.\n\n-   Transform the simple feature `data.frame` into an R `SpatialPolygonDataFrame` object using relevant functions from the `sf` package.\n\n-   Perform cluster analysis using `hclust()` from Base R.\n\n-   Execute spatially constrained cluster analysis with `skater()` from Base R.\n\n-   Visualize the analysis output through the `ggplot2` and `tmap` packages.\n\n### **Getting Started Explanation**\n\n#### **Analytical Question**\n\nIn spatial policy and geobusiness, it is common to divide markets or planning areas into homogeneous regions using multivariate data. In this exercise, I focused on dividing Shan State in Myanmar into homogeneous regions using several Information and Communication Technology (ICT) indicators, including Radio, Television, Landline Phone, Mobile Phone, Computer, and Internet at home.\n\n### **Installing and Loading R Packages Explanation**\n\nIn the code provided, I installed and loaded several R packages using `pacman::p_load()`, which efficiently manages package installation and loading:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\n\n## **Data Import and Preparation Explanation**\n\n#### **Importing Geospatial Data into R Environment**\n\nI used the `st_read()` function from the `sf` package to read geospatial data for Myanmar township boundaries. I filtered the data to only include three regions of Shan State (East, North, and South) and selected columns 2 to 7. The resultant geospatial data was stored in `shan_sf`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\EasonXu-HY99\\IS415\\Hands-on_Ex\\Hands-on_Ex08\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\nThe dataset is then displayed using the following functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 55 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE       DT   DT_PCODE        TS  TS_PCODE\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(shan_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 55\nColumns: 7\n$ ST       <chr> \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (South)…\n$ ST_PCODE <chr> \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR014\", \"…\n$ DT       <chr> \"Mongmit\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Mongmit\", \"Ta…\n$ DT_PCODE <chr> \"MMR015D008\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", \"MMR0…\n$ TS       <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"Kalaw…\n$ TS_PCODE <chr> \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR01501…\n$ geometry <MULTIPOLYGON [°]> MULTIPOLYGON (((96.96001 23..., MULTIPOLYGON (((…\n```\n\n\n:::\n:::\n\n\n\n#### **Importing Aspatial Data into R Environment**\n\nThe aspatial dataset, which contains ICT-related data for Shan State, is imported using `read_csv()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 55 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): District Pcode, District Name, Township Pcode, Township Name\ndbl (7): Total households, Radio, Television, Land line phone, Mobile phone,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n District Pcode     District Name      Township Pcode     Township Name     \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n Total households     Radio         Television    Land line phone \n Min.   : 3318    Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711    1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685    Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369    Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471    3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604    Max.   :30176   Max.   :62388   Max.   :6736.0  \n  Mobile phone      Computer      Internet at home\n Min.   :  150   Min.   :  20.0   Min.   :   8.0  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0  \n Median : 3559   Median : 244.0   Median : 316.0  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0  \n```\n\n\n:::\n:::\n\n\n\n### **Spatially Constrained Clustering: SKATER Approach**\n\nIn this section, I applied the **SKATER (Spatial 'K'luster Analysis by Tree Edge Removal)** approach to perform spatially constrained clustering. I started by converting the `shan_sf` spatial data into an `as_Spatial()` format, which is necessary for certain spatial clustering methods.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sp <- as_Spatial(shan_sf)\n```\n:::\n\n\n\n### **Computing Neighbour ListComputing Neighbour List**\n\nI created a neighbor list using the `poly2nb()` function, which identifies which polygons (townships) in `shan_sp` share borders. The neighbor relationships are crucial for defining the spatial structure of the data, and I summarized the neighbor list to understand its characteristics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sp)\nsummary(shan.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(\n  st_centroid(st_geometry(shan_sf)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=grey(.5))\nplot(shan.nb,\n     coords, \n     col=\"blue\", \n     add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n### **Computing Minimum Spanning Tree (MST)**\n\n#### **Calculating Edge Costs**\n\nI calculated the edge costs for the minimum spanning tree based on the ICT variables. First, I prepared the `ict_derived` dataset by calculating the proportion of households with each ICT service and merged this dataset with the `shan_sf` spatial data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \nwrite_rds(shan_sf, \"data/rds/shan_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- read_rds(\"data/rds/shan_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1  286.1852 554.1313   35.30618  260.6944    12.15939\n2  417.4647 505.1300   19.83584  162.3917    12.88190\n3  484.5215 260.5734   11.93591  120.2856     4.41465\n4  231.6499 541.7189   28.54454  249.4903    13.76255\n5  449.4903 708.6423   72.75255  392.6089    16.45042\n6  280.7624 611.6204   42.06478  408.7951    29.63160\n7  318.6118 535.8494   39.83270  214.8476    18.97032\n8  387.1017 630.0035   31.51366  320.5686    21.76677\n9  349.3359 547.9456   38.44960  323.0201    15.76465\n10 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(shan_ict, \"data/rds/shan_ict.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- read_rds(\"data/rds/shan_ict.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlcosts <- nbcosts(shan.nb, shan_ict)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(shan.w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0       S1        S2\nB 55 3025 76267.65 58260785 522016004\n```\n\n\n:::\n:::\n\n\n\n### **Constructing the Minimum Spanning Tree**\n\nI computed the minimum spanning tree (MST) from the list-weight object using the `mstree()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.mst <- mstree(shan.w)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"mst\"    \"matrix\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54  3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]      [,3]\n[1,]   31   25 229.44658\n[2,]   25   10 163.95741\n[3,]   10    1 144.02475\n[4,]   10    9 157.04230\n[5,]    9    8  90.82891\n[6,]    8    6 140.01101\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n                 border=gray(.5))\nplot.mst(shan.mst, \n         coords, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n### **Computing Spatially Constrained Clusters Using the SKATER Method**\n\nI performed spatially constrained clustering using the **SKATER** method. The SKATER algorithm removes edges from the minimum spanning tree to create clusters based on both spatial proximity and similarity in ICT indicators.\n\nI used the `spdep::skater()` function to compute 6 clusters (by making 5 cuts) based on the MST (Minimum Spanning Tree) and the ICT indicators.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust6 <- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(clust6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 8\n $ groups      : num [1:55] 3 3 6 3 3 3 3 3 3 3 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:22] 13 48 54 55 45 37 34 16 25 31 ...\n  .. ..$ edge: num [1:21, 1:3] 48 55 54 37 34 16 45 31 13 13 ...\n  .. ..$ ssw : num 3423\n  ..$ :List of 3\n  .. ..$ node: num [1:18] 47 27 53 38 42 15 41 51 43 32 ...\n  .. ..$ edge: num [1:17, 1:3] 53 15 42 38 41 51 15 27 15 43 ...\n  .. ..$ ssw : num 3759\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 2 6 8 1 36 4 10 9 46 5 ...\n  .. ..$ edge: num [1:10, 1:3] 6 1 8 36 4 6 8 10 10 9 ...\n  .. ..$ ssw : num 1458\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 44 20\n  .. ..$ edge: num [1, 1:3] 44 20 95\n  .. ..$ ssw : num 95\n  ..$ :List of 3\n  .. ..$ node: num 23\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 3\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 12613\n $ ssw         : num [1:6] 12613 10977 9962 9540 9123 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nccs6 <- clust6$groups\nccs6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3 3 6 3 3 3 3 3 3 3 2 1 1 1 2 1 1 1 2 4 1 2 5 1 1 1 2 1 2 2 1 2 2 1 1 3 1 2\n[39] 2 2 2 2 2 4 1 3 2 1 1 1 2 1 2 1 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(ccs6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nccs6\n 1  2  3  4  5  6 \n22 18 11  2  1  1 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=gray(.5))\nplot(clust6, \n     coords, \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n### **Visualizing the Clusters in a Choropleth Map**\n\nTo visualize the clusters further, I computed a distance matrix using the Euclidean method and applied hierarchical clustering (`hclust`) to compare it with the SKATER clusters. I also created a choropleth map to display both sets of clusters side by side.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(shan_ict, method = 'euclidean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(hclust_ward, k=6))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\n## **Spatially Constrained Clustering Using the ClustGeo Method**\n\n#### **A Short Note About ClustGeo Package**\n\nThe `ClustGeo` package allows me to perform spatially constrained cluster analysis by combining attribute-based dissimilarity and spatial/geographical constraints. It offers a Ward-like hierarchical clustering algorithm (`hclustgeo()`) that accounts for both data attributes and spatial relationships.\n\nI used two dissimilarity matrices: `D0` for attributes (such as ICT variables) and `D1` for spatial constraints. The goal is to find a balance between the two by using a mixing parameter, alpha. This parameter influences how much weight is given to spatial proximity when forming clusters.\n\n### **Ward-Like Hierarchical Clustering Using ClustGeo**\n\nI began by performing standard hierarchical clustering using `hclustgeo()` based on the attribute dissimilarity matrix (`proxmat`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\n#### Mapping the clusters formed\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n\n### **Spatially Constrained Hierarchical Clustering**\n\nTo introduce spatial constraints, I computed the distance matrix between townships using `st_distance()` and then used the `choicealpha()` function to find an optimal value for alpha that balances spatial contiguity and clustering quality.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-40-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(clustG, k=6))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\n\n## **Visual Interpretation of Clusters**\n\n#### **Visualizing Individual Clustering Variables**\n\nI created boxplots to explore how the values of individual ICT indicators vary across the clusters formed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = shan_sf_ngeo_cluster,\n       aes(x = CLUSTER, y = RADIO_PR)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n\n#### **Multivariate Visualization**\n\nI used parallel coordinate plots to visualize the multivariate relationships between ICT variables across the clusters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(CLUSTER) %>%\n  summarise(mean_RADIO_PR = mean(RADIO_PR),\n            mean_TV_PR = mean(TV_PR),\n            mean_LLPHONE_PR = mean(LLPHONE_PR),\n            mean_MPHONE_PR = mean(MPHONE_PR),\n            mean_COMPUTER_PR = mean(COMPUTER_PR))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  CLUSTER mean_RADIO_PR mean_TV_PR mean_LLPHONE_PR mean_MPHONE_PR\n  <chr>           <dbl>      <dbl>           <dbl>          <dbl>\n1 1               221.        521.            44.2           246.\n2 2               237.        402.            23.9           134.\n3 3               300.        611.            52.2           392.\n4 4               196.        744.            99.0           651.\n5 5               124.        224.            38.0           132.\n6 6                98.6       499.            74.5           468.\n# ℹ 1 more variable: mean_COMPUTER_PR <dbl>\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}